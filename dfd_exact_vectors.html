<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DFD — ψ Field Optics & Matter (Purist, Exact Equations)</title>
<style>
  :root { --bg:#05070d; --fg:#eaf2ff; --muted:#a9b9ff; --cyan:#48d4ff; --green:#4ef07a; --amber:#ffd24d; --red:#ff6b6b;}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:15px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .layout{display:flex;height:100%}
  #view{flex:1;position:relative;background:radial-gradient(1200px 700px at 60% 40%, #0c1f3f 0%, #07132a 60%, #040a18 100%)}
  canvas{position:relative; z-index:0; width:100%;height:100%;display:block}
  .panel{width:480px;background:linear-gradient(180deg,#07132a,#0b1938);border-left:1px solid #ffffff18;padding:14px 16px;overflow:auto}
  h1{font-size:16px;margin:0 0 8px 0}
  h2{font-size:13px;margin:14px 0 6px 0;color:#d9e6ff}
  label{display:block;margin:8px 0 4px 0}
  input[type=range]{width:100%}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{background:#0d2747;border:1px solid #315a86;color:#eaf2ff;border-radius:8px;padding:8px 10px;cursor:pointer}
  button.primary{background:#143b6d;border-color:#3d77b1}
  button.warn{background:#4c1620;border-color:#8a3a47}
  .pill{display:inline-block;padding:4px 10px;border-radius:999px;background:#ffffff12;border:1px solid #ffffff22;font-size:12px;margin-right:6px}
  .legend{position:absolute;right:12px;bottom:12px;background:#000b;border:1px solid #ffffff25;border-radius:10px;padding:8px 10px;font-size:12px; z-index:3}
  .legend i{display:inline-block;width:12px;height:12px;border-radius:50%;margin-right:6px;box-shadow:0 0 8px #fff2}
  .hud{position:absolute;left:12px;top:12px;background:#000b;border:1px solid #ffffff25;border-radius:12px;padding:10px 12px;backdrop-filter:blur(3px);max-width:860px; z-index:3}
  .kpi{font-weight:800}
  .note{font-size:12px;color:#b7c6ff}
  .disclaimer{position:absolute;left:12px;bottom:12px;background:#000c;border:1px solid #ffffff25;border-radius:10px;padding:10px 12px;font-size:12px;max-width:860px; z-index:2}
  .disclaimer b{color:#eaf2ff}
  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:#000e;backdrop-filter:blur(2px); z-index:5}
  .card{background:#081a37;border:1px solid #ffffff30;border-radius:12px;padding:16px;min-width:360px;max-width:540px; box-shadow:0 8px 30px #0008}
  .progress{height:10px;background:#041024;border:1px solid #234; border-radius:8px;overflow:hidden;margin-top:10px}
  .bar{height:100%;width:0%;background:linear-gradient(90deg,#3fb2ff,#48d4ff);transition:width 0.06s}
  .status{font-size:12px;color:#b7c6ff;margin-top:6px}
  .badge{padding:2px 8px;border-radius:999px;border:1px solid #ffffff2a;font-size:11px;margin-left:8px}
  .badge.good{background:#1d3b1d;color:#c9ffd0;border-color:#2f6f39}
  .badge.warn{background:#43211f;color:#ffd9d6;border-color:#7f3d36}
  .empty-hint{position:absolute; inset:auto 12px 90px auto; background:#000b; border:1px dashed #ffffff35; color:#b7c6ff; padding:6px 8px; border-radius:8px; font-size:12px; z-index:2; display:none}
</style>
</head>
<body>
<div class="layout">
  <div id="view">
    <canvas id="cv"></canvas>

    <div class="hud">
      <div class="row">
        <span class="pill">n = e<sup>ψ</sup></span>
        <span class="pill">c<sub>1</sub> = e<sup>−ψ</sup></span>
        <span class="pill">ṙ = c<sub>1</sub> v</span>
        <span class="pill">ṽ = c<sub>1</sub>(I − v vᵀ)∇ψ</span>
        <span class="pill">a = (c²/2)∇ψ</span>
        <span id="modeBadge" class="badge good">Purist (Exact ψ)</span>
      </div>
      <div class="note" style="margin-top:6px">
        Exact DFD equations; ψ = 2GM/r. No damping, no caps, no clamped core. Contours are precomputed for clarity.
      </div>
    </div>

    <div class="legend">
      <div><i style="background:var(--amber)"></i> ψ contour</div>
      <div><i style="background:var(--cyan)"></i> photon</div>
      <div><i style="background:var(--green)"></i> test mass</div>
    </div>

    <div id="computeOverlay" class="overlay">
      <div class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
          <div>
            <div style="font-weight:700">Computing ψ-grid & contours…</div>
            <div class="status" id="statusText">Initializing</div>
          </div>
          <div class="badge">GM=<span id="gmBadge">—</span></div>
        </div>
        <div class="progress"><div id="bar" class="bar"></div></div>
        <div class="note" style="margin-top:8px">
          Purist = exact equations. This step ensures clean contours & stable bends. No heuristics.
        </div>
      </div>
    </div>

    <div id="emptyHint" class="empty-hint">No contours yet. Click “Recompute grid/contours”.</div>

    <div class="disclaimer">
      <b>Model disclaimers.</b> Exact DFD ray & matter laws (2D slice): ψ(x,y) = 2GM/r, c<sub>1</sub> = e<sup>−ψ</sup>,
      rays: ṙ = c<sub>1</sub> v, ṽ = c<sub>1</sub>(I−vvᵀ)∇ψ; matter: a = (c²/2)∇ψ. No GR curvature language, no two-way-speed hacks.
      Optional “Approximate” adds a soft core & UX cap for frame-rate only; it’s <b>off by default</b>.
    </div>
  </div>

  <div class="panel">
    <h1>DFD Controls</h1>
    <div class="note">Purist mode is exact. Changing GM or resolution re-computes ψ-grid and contours.</div>

    <h2>Mode</h2>
    <div class="row">
      <label><input id="purist" type="checkbox" checked/> Purist (exact ψ; no caps)</label>
      <label><input id="approx" type="checkbox"/> Approximate (soft core + UX cap)</label>
    </div>

    <h2>Field</h2>
    <label>GM (strength) <span id="gmVal" class="kpi"></span></label>
    <input id="gm" type="range" min="0.5" max="12" step="0.1" value="3"/>
    <label>Contours</label>
    <input id="iso" type="range" min="6" max="64" step="1" value="24"/>
    <div class="row">
      <label><input id="showIso" type="checkbox" checked/> show ψ-contours</label>
      <label><input id="showGrad" type="checkbox"/> show ∇ψ vectors</label>
      <label><input id="finiteCore" type="checkbox"/> finite radius core (Approximate only)</label>
      <label>R<sub>core</sub> <input id="rcore" type="range" min="0.2" max="3.0" step="0.05" value="0.8"/></label>
    </div>
    <div class="row">
      <button id="recompute" class="primary">Recompute grid/contours</button>
      <button id="resetView">Reset view</button>
    </div>

    <h2>Integrator</h2>
    <label>Ray time step (dt)</label>
    <input id="raydt" type="range" min="0.03" max="1.50" step="0.03" value="0.45"/>
    <label>Matter time step (dt)</label>
    <input id="mtdt" type="range" min="0.03" max="1.20" step="0.01" value="0.35"/>

    <div class="row">
      <label><input id="fastMode" type="checkbox"/> Fast mode (relaxes adaptivity; not physics)</label>
      <label style="margin-left:8px;">β<sub>max</sub> (Approx.)
        <input id="betaMax" type="range" min="0.10" max="0.95" step="0.01" value="0.70"/>
      </label>
    </div>
    <div class="note">Fast Mode & β<sub>max</sub> ignored in Purist (exact) mode.</div>

    <h2>Launch</h2>
    <div class="row">
      <button id="ph" class="primary">Photon →</button>
      <button id="ms">Test mass →</button>
      <button id="burst">Photon burst</button>
      <button id="clear" class="warn">Clear</button>
    </div>
    <div class="row">
      <label><input id="autoPh" type="checkbox" checked/> stream photons</label>
      <label><input id="autoMs" type="checkbox"/> periodic masses</label>
    </div>

    <h2>Resolution</h2>
    <div class="note">Higher grid density → crisper contours (recompute required).</div>
    <label>Grid step (px)</label>
    <input id="gridStep" type="range" min="8" max="60" step="2" value="28"/>
  </div>
</div>

<script>
// ---------- Canvas & Camera ----------
const cv = document.getElementById('cv');
const cx = cv.getContext('2d');
let W=0,H=0,dpr=1;

function resize(){
  dpr=window.devicePixelRatio||1;
  W=cv.clientWidth|0; H=cv.clientHeight|0;
  cv.width=W*dpr; cv.height=H*dpr;
  cx.setTransform(dpr,0,0,dpr,0,0);
  scheduleRecompute('resize');
}
addEventListener('resize',resize);

// ---------- Camera ----------
let cam={x:0,y:0,z:250};
function S([x,y]){return[(x-cam.x)*cam.z+W/2,(y-cam.y)*cam.z+H/2]}
function Wc([sx,sy]){return[(sx-W/2)/cam.z+cam.x,(sy-H/2)/cam.z+cam.y]}
let drag=false,last=[0,0];
cv.addEventListener('mousedown',e=>{drag=true; last=[e.clientX,e.clientY]});
addEventListener('mouseup',()=>drag=false);
addEventListener('mousemove',e=>{if(drag){cam.x-=(e.clientX-last[0])/cam.z; cam.y-=(e.clientY-last[1])/cam.z; last=[e.clientX,e.clientY]}});
cv.addEventListener('wheel',e=>{const k=Math.exp(-e.deltaY*0.0013); const m=Wc([e.clientX,e.clientY]); cam.z*=k; const m2=Wc([e.clientX,e.clientY]); cam.x+=m[0]-m2[0]; cam.y+=m[1]-m2[1]; scheduleRecompute('zoom/pan');});

// ---------- Params / Mode ----------
const P={ GM:3, GM_target:3, iso:24, showIso:true, showGrad:false,
          raydt:0.45, mtdt:0.35,
          purist:true, useSoftCore:false, rcore:0.8,
          fast:false, betaMax:0.70,
          gridStep:28 };
const C={x:0,y:0}; const eps=1e-9; const GM_SMOOTH=0.10;

// ---------- Field (Exact + Optional Soft Core in Approx mode) ----------
function psi_raw(x,y){
  const dx=x-C.x, dy=y-C.y; const r=Math.hypot(dx,dy)+eps;
  if (P.purist || !P.useSoftCore) return 2*P.GM/r;        // exact ψ
  const rc=P.rcore, GM=P.GM;                               // approx ψ (soft core)
  if (r>=rc) return 2*GM/r;
  const a=3*GM/rc, b=-GM/(rc**3); return a + b*r*r;
}
function gradPsi(x,y){
  const dx=x-C.x, dy=y-C.y; const r=Math.hypot(dx,dy)+eps; const ux=dx/r, uy=dy/r;
  if (P.purist || !P.useSoftCore){ const k=-2*P.GM/(r*r); return [k*ux,k*uy]; }
  const rc=P.rcore, GM=P.GM; if (r>=rc){ const k=-2*GM/(r*r); return [k*ux,k*uy]; }
  const dpsi_dr=-2*GM*r/(rc**3); return [dpsi_dr*ux,dpsi_dr*uy];
}
function c1_at(x,y){ return Math.exp(-psi_raw(x,y)); }

// ---------- Entities ----------
const photons=[], masses=[];
function addPhoton(){const y=(Math.random()*0.6-0.3)*(H/cam.z)*0.8; photons.push({x:-W*0.55/cam.z+cam.x, y:y+cam.y, vx:1, vy:0, path:[], alive:true});}
function addMass(){const y=(Math.random()*0.6-0.3)*(H/cam.z)*0.6; masses.push({x:-W*0.45/cam.z+cam.x, y:y+cam.y, vx:0.6, vy:0, path:[], alive:true});}

// ---------- Integrators ----------
function stepPhoton(p){
  const g=gradPsi(p.x,p.y), gmag=Math.hypot(g[0],g[1]);
  const c1=c1_at(p.x,p.y);
  const dt0=(P.fast?1.15:1.0)*P.raydt*(1/cam.z)*40;
  const dt = dt0 / (1 + 2.5*gmag); // adaptivity (numeric only)
  let vx=p.vx, vy=p.vy; const vL=Math.hypot(vx,vy)||1; vx/=vL; vy/=vL;
  const dot=g[0]*vx + g[1]*vy;
  const ax=c1*(g[0]-dot*vx), ay=c1*(g[1]-dot*vy);
  vx+=ax*dt; vy+=ay*dt; const L=Math.hypot(vx,vy)||1; vx/=L; vy/=L;
  p.x+=c1*vx*dt; p.y+=c1*vy*dt; p.vx=vx; p.vy=vy; p.path.push([p.x,p.y]);
  const s=S([p.x,p.y]);
  p.alive = s[0]>-160 && s[0]<W+160 && s[1]>-160 && s[1]<H+160 && p.path.length<12000;
}
function stepMass(m){
  const dt=(P.fast?1.20:1.0)*P.mtdt*(1/cam.z)*40;
  const g=gradPsi(m.x,m.y);
  m.vx+=0.5*g[0]*dt; m.vy+=0.5*g[1]*dt;        // a ∝ ∇ψ (units absorbed)
  // Optional UX cap ONLY in Approximate mode
  if(!P.purist && !P.fast){
    const c1rim = Math.exp(-2*P.GM/Math.max(P.rcore,eps));
    const vmax  = Math.max(1e-4, P.betaMax * c1rim);
    const vmag  = Math.hypot(m.vx,m.vy);
    if(vmag>vmax){ const s=vmax/vmag; m.vx*=s; m.vy*=s; }
  }
  m.x+=m.vx*dt; m.y+=m.vy*dt;
  m.path.push([m.x,m.y]);
  const s=S([m.x,m.y]);
  m.alive=s[0]>-160&&s[0]<W+160&&s[1]>-160&&s[1]<H+160&&m.path.length<12000;
}

// ---------- Precompute ψ-grid & Contours (with progress) ----------
let grid=null, contours=[], recomputeScheduled=false;
const overlay = document.getElementById('computeOverlay');
const bar = document.getElementById('bar');
const statusText = document.getElementById('statusText');
const gmBadge = document.getElementById('gmBadge');
const emptyHint = document.getElementById('emptyHint');

function showOverlay(msg){ overlay.style.display='flex'; statusText.textContent=msg||'Working…'; bar.style.width='0%'; gmBadge.textContent=P.GM.toFixed(2); }
function hideOverlay(){ overlay.style.display='none'; }

function scheduleRecompute(why){
  if (recomputeScheduled) return;
  recomputeScheduled = true;
  // If canvas isn’t sized yet, delay until next frame
  requestAnimationFrame(()=>{ if(W===0||H===0){ measureThenRecompute(why); } else { recomputeGrid(why); } });
}
function measureThenRecompute(why){
  // Force a measure & then recompute
  W=cv.clientWidth|0; H=cv.clientHeight|0;
  cv.width=W*dpr; cv.height=H*dpr; cx.setTransform(dpr,0,0,dpr,0,0);
  recomputeGrid(why||'measure');
}

function recomputeGrid(why){
  recomputeScheduled=false;
  showOverlay(`Setting up (${why})`);
  emptyHint.style.display='none';

  const step = Math.max(8, parseInt(document.getElementById('gridStep').value,10));
  P.gridStep = step;

  const cols = Math.max(3, Math.ceil(W/step)+3);
  const rows = Math.max(3, Math.ceil(H/step)+3);
  // Align grid to current camera/world box
  const TL = Wc([0,0]);    // top-left world coord
  grid = {cols, rows, step, x0:TL[0], y0:TL[1], psi:new Float32Array(cols*rows)};

  let i=0, total=cols*rows;
  statusText.textContent='Computing ψ-field…';
  (function chunk(){
    const batch = Math.min(6000, total-i);
    for(let k=0;k<batch;k++,i++){
      const gx = i % cols;
      const gy = (i/cols)|0;
      const wx = grid.x0 + gx*step/cam.z;
      const wy = grid.y0 + gy*step/cam.z;
      grid.psi[i] = psi_raw(wx,wy);
    }
    bar.style.width = ((i/total)*100).toFixed(1)+'%';
    if(i<total){ requestAnimationFrame(chunk); }
    else { precomputeContours(); }
  })();
}

function samplePsiWorld(wx,wy){
  if(!grid) return psi_raw(wx,wy);
  const {x0,y0,step,cols,rows,psi}=grid;
  const gx=(wx - x0)*cam.z/step, gy=(wy - y0)*cam.z/step;
  const ix=Math.floor(gx), iy=Math.floor(gy);
  const tx=gx-ix, ty=gy-iy;
  function val(i,j){
    const ii=Math.max(0,Math.min(cols-1,i));
    const jj=Math.max(0,Math.min(rows-1,j));
    return psi[jj*cols+ii];
  }
  const v00=val(ix,iy), v10=val(ix+1,iy), v01=val(ix,iy+1), v11=val(ix+1,iy+1);
  return (1-tx)*(1-ty)*v00 + tx*(1-ty)*v10 + (1-tx)*ty*v01 + tx*ty*v11;
}

function precomputeContours(){
  statusText.textContent='Tracing ψ-contours…';
  contours.length=0;
  const levels = P.iso;
  const vmin = 0.08, vmax = 0.08*levels;
  const targets = Array.from({length:levels},(_,i)=>vmin*(i+1));
  const step = grid.step;
  const cols = grid.cols-1, rows=grid.rows-1;

  let idx=0, total=targets.length*cols*rows;
  (function chunk(){
    let count=0;
    while(count<2000 && idx<total){
      const l = Math.floor(idx/(cols*rows));
      const cell = idx % (cols*rows);
      const cx = cell % cols, cy=(cell/cols)|0;
      traceCell(cx,cy,targets[l]);
      idx++; count++;
    }
    bar.style.width=((idx/total)*100).toFixed(1)+'%';
    if(idx<total){ requestAnimationFrame(chunk); }
    else { hideOverlay(); if(!contours.length) emptyHint.style.display='block'; }
  })();

  function worldAtCell(ix,iy){
    const wx = grid.x0 + ix*step/cam.z;
    const wy = grid.y0 + iy*step/cam.z;
    return [wx,wy];
  }
  function traceCell(ix,iy,target){
    const A=worldAtCell(ix,iy);
    const B=worldAtCell(ix+1,iy);
    const Cw=worldAtCell(ix,iy+1);
    const D=worldAtCell(ix+1,iy+1);
    const vA=samplePsiWorld(A[0],A[1]);
    const vB=samplePsiWorld(B[0],B[1]);
    const vC=samplePsiWorld(Cw[0],Cw[1]);
    const vD=samplePsiWorld(D[0],D[1]);
    const sA=vA>target, sB=vB>target, sC=vC>target, sD=vD>target;
    const pts=[];
    function ip(P,Q,vP,vQ){
      const t = (target-vP)/(vQ-vP);
      return [P[0]+t*(Q[0]-P[0]), P[1]+t*(Q[1]-P[1])];
    }
    if(sA!==sB) pts.push(ip(A,B,vA,vB));
    if(sB!==sD) pts.push(ip(B,D,vB,vD));
    if(sC!==sD) pts.push(ip(Cw,D,vC,vD));
    if(sA!==sC) pts.push(ip(A,Cw,vA,vC));
    if(pts.length===2){ contours.push([pts[0],pts[1],target]); }
    else if(pts.length===4){ contours.push([pts[0],pts[1],target]); contours.push([pts[2],[pts[3][0],pts[3][1]],target]); }
  }
}

// ---------- Draw ----------
function drawGrad(){
  if(!P.showGrad) return;
  cx.save(); cx.strokeStyle='rgba(120,220,255,0.55)';
  const step=Math.max(22,140/cam.z);
  for(let y=-H;y<=H;y+=step){ for(let x=-W;x<=W;x+=step){
    const w=Wc([x+W/2,y+H/2]); const g=gradPsi(w[0],w[1]);
    const p1=S([w[0],w[1]]); const p2=S([w[0]+g[0]*140/cam.z, w[1]+g[1]*140/cam.z]);
    cx.beginPath(); cx.moveTo(p1[0],p1[1]); cx.lineTo(p2[0],p2[1]); cx.stroke();
  }} cx.restore();
}
function drawContours(){
  if(!P.showIso || !contours.length) return;
  cx.save(); cx.strokeStyle='rgba(255,210,80,0.40)'; cx.lineWidth=1;
  for(const seg of contours){ const a=S(seg[0]), b=S(seg[1]); cx.beginPath(); cx.moveTo(a[0],a[1]); cx.lineTo(b[0],b[1]); cx.stroke(); }
  cx.restore();
}
function draw(){
  cx.clearRect(0,0,W,H);
  drawContours();
  drawGrad();

  const c=S([C.x,C.y]); cx.fillStyle='#fff'; cx.beginPath(); cx.arc(c[0],c[1],5,0,6.283); cx.fill();

  function trails(list,col){ cx.save(); cx.strokeStyle=col; cx.lineWidth=1.6; cx.globalAlpha=0.97;
    for(const p of list){ if(p.path.length<2) continue; cx.beginPath(); const a=S(p.path[0]); cx.moveTo(a[0],a[1]);
      for(let i=1;i<p.path.length;i++){ const s=S(p.path[i]); cx.lineTo(s[0],s[1]); } cx.stroke(); } cx.restore(); }
  trails(photons,'#48d4ff'); trails(masses,'#4ef07a');
}

// ---------- UI ----------
const gm=document.getElementById('gm'), gmVal=document.getElementById('gmVal');
const iso=document.getElementById('iso');
const showIso=document.getElementById('showIso');
const showGrad=document.getElementById('showGrad');
const finiteCore=document.getElementById('finiteCore');
const rcore=document.getElementById('rcore');
const ph=document.getElementById('ph');
const ms=document.getElementById('ms');
const burst=document.getElementById('burst');
const clearBtn=document.getElementById('clear');
const autoPh=document.getElementById('autoPh');
const autoMs=document.getElementById('autoMs');
const raydt=document.getElementById('raydt');
const mtdt=document.getElementById('mtdt');
const fastMode=document.getElementById('fastMode');
const betaMax=document.getElementById('betaMax');
const purist=document.getElementById('purist');
const approx=document.getElementById('approx');
const gridStep=document.getElementById('gridStep');
const recomputeBtn=document.getElementById('recompute');
const resetView=document.getElementById('resetView');
const modeBadge=document.getElementById('modeBadge');

function syncGM(){ P.GM_target=parseFloat(gm.value); gmVal.textContent=P.GM_target.toFixed(2); gmBadge.textContent=P.GM_target.toFixed(2); scheduleRecompute('GM change'); }
gm.addEventListener('input',syncGM); syncGM();

iso.addEventListener('input',e=>{P.iso=parseInt(e.target.value,10); scheduleRecompute('iso levels');});
showIso.addEventListener('change',e=>P.showIso=e.target.checked);
showGrad.addEventListener('change',e=>P.showGrad=e.target.checked);

finiteCore.addEventListener('change',e=>{ if(P.purist){ e.target.checked=false; return; } P.useSoftCore = e.target.checked; scheduleRecompute('core toggle'); });
rcore.addEventListener('input',e=>{ P.rcore=parseFloat(e.target.value); if(P.useSoftCore) scheduleRecompute('rcore'); });

ph.addEventListener('click',addPhoton);
ms.addEventListener('click',addMass);
burst.addEventListener('click',()=>{for(let i=0;i<150;i++) addPhoton();});
clearBtn.addEventListener('click',()=>{photons.length=0; masses.length=0;});

raydt.addEventListener('input',e=>P.raydt=parseFloat(e.target.value));
mtdt.addEventListener('input',e=>P.mtdt=parseFloat(e.target.value));
fastMode.addEventListener('change',e=>P.fast=e.target.checked);
betaMax.addEventListener('input',e=>P.betaMax=parseFloat(e.target.value));

purist.addEventListener('change',()=>{
  P.purist=purist.checked;
  if(P.purist){ approx.checked=false; P.useSoftCore=false; finiteCore.checked=false; P.fast=false; fastMode.checked=false; modeBadge.textContent='Purist (Exact ψ)'; modeBadge.className='badge good'; }
  scheduleRecompute('mode change');
});
approx.addEventListener('change',()=>{
  if(approx.checked){ P.purist=false; purist.checked=false; P.useSoftCore=finiteCore.checked; modeBadge.textContent='Approximate (Soft core + UX cap)'; modeBadge.className='badge warn'; }
  else { P.purist=true; purist.checked=true; P.useSoftCore=false; finiteCore.checked=false; modeBadge.textContent='Purist (Exact ψ)'; modeBadge.className='badge good'; }
  scheduleRecompute('mode change');
});

gridStep.addEventListener('input',()=>scheduleRecompute('grid step'));
recomputeBtn.addEventListener('click',()=>scheduleRecompute('manual'));
resetView.addEventListener('click',()=>{ cam.x=0; cam.y=0; cam.z=250; scheduleRecompute('view reset'); });

// ---------- Main loop ----------
let acc=0;
function loop(){
  requestAnimationFrame(loop);
  P.GM += (P.GM_target - P.GM) * GM_SMOOTH;
  acc+=1/60;
  if(autoPh.checked && acc>0.06){ addPhoton(); acc=0; }
  if(autoMs.checked && Math.random()<0.02){ addMass(); }
  for(const p of photons) if(p.alive) stepPhoton(p);
  for(const m of masses)  if(m.alive) stepMass(m);
  for(let i=photons.length-1;i>=0;i--) if(!photons[i].alive) photons.splice(i,1);
  for(let i=masses.length-1;i>=0;i--)   if(!masses[i].alive)  masses.splice(i,1);
  draw();
}
requestAnimationFrame(loop);

// ---------- Boot: force measure, then initial recompute ----------
(function boot(){
  // ensure canvas is sized before first compute
  dpr=window.devicePixelRatio||1;
  W=cv.clientWidth|0; H=cv.clientHeight|0;
  cv.width=W*dpr; cv.height=H*dpr; cx.setTransform(dpr,0,0,dpr,0,0);
  scheduleRecompute('initial');
})();
</script>
</body>
</html>
